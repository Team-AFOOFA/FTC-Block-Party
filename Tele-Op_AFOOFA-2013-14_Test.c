#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTTMUX,         sensorAnalogInactive)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Collector,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
/*
const tMUXSensor F_Force = msensor_S2_4;
const tMUXSensor B_Force = msensor_S2_1;
const tMUXSensor LeftIR = msensor_S2_2;
const tMUXSensor RightIR = msensor_S2_3;

int F_val = 0; //variables for the front sensor values
int B_val = 0; //variables for the back sensor value

void OnFrontLamp()
{
  motor[frontLamp] = 100;
}
void OffFrontLamp()
{
  motor[frontLamp] = 0;
}
void OnBackLamp()
{
  motor[backLamp] = 100;
}
void OffBackLamp()
{
  motor[backLamp] = 0;
}
task FrontDetectRing()
{
	while(1)
	{
		if(F_val > 250)
			OnFrontLamp();
		else
			OffFrontLamp();
		wait1Msec(50);
	}
}
task BackDetectRing()
{
	while(1)
	{
		if(B_val > 250)
			OnBackLamp();
		else
			OffBackLamp();
		wait1Msec(50);
	}
}
*/
bool taskEntered = false;
bool taskEnteredFlag = false;
//bool taskEnteredSlideLift = false;

//returns true value if down button is pressed on Dpad on joystick 2, returns false value if down button on joystick 2 is not pressed.
/* bool isUPJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 0) return true;
  else return false;
}
//returns true value if down button is pressed on Dpad on joystick 2, returns false value if down button on joystick 2 is not pressed.
 bool isDOWNJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 4) return true;
  else return false;
}
//returns true value if left button is pressed on Dpad on joystick 2, returns false value if left button on joystick 2 is not pressed.
 bool isLEFTJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 6) return true;
  else return false;
}
//returns true value if right button is pressed on Dpad on joystick 2, returns false value if right button on joystick 2 is not pressed.
 bool isRIGHTJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 2) return true;
  else return false;
}
//returns true value if upleft button is pressed on Dpad on joystick 2, returns false value if upleft button on joystick 2 is not pressed.
 bool isUPLEFTJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 1) return true;
  else return false;
}
//returns true value if upright button is pressed on Dpad on joystick 2, returns false value if upright button on joystick 2 is not pressed.
 bool isUPRIGHTJoy2DPadPressed(TJoystick js)
{
  if(joystick.joy2_TopHat == 7) return true;
  else return false;
}
//returns true value if downleft button is pressed on Dpad on joystick 2, returns false value if downleft button on joystick 2 is not pressed.
 bool isDOWNLEFTJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 5) return true;
  else return false;
}
//returns true value if downright button is pressed on Dpad on joystick 2, returns false value if downright button on joystick 2 is not pressed.
 bool isDOWNRIGHTJoy2DPadPressed(TJoystick js)
{
  if(js.joy2_TopHat == 3) return true;
  else return false;
}
*/
///

//returns true value if up button is pressed on Dpad on joystick 1, returns false value if up button on joystick 2 is not pressed.
 bool IsUPJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 0)
  	return true;
  else return false;
}
//returns true value if down button is pressed on Dpad on joystick 1, returns false value if down button on joystick 2 is not pressed.
 bool isDOWNJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 4) return true;
  else return false;
}
//returns true value if left button is pressed on Dpad on joystick 2, returns false value if left button on joystick 2 is not pressed.
 bool isLEFTJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 6) return true;
  else return false;
}
//returns true value if right button is pressed on Dpad on joystick 2, returns false value if right button on joystick 2 is not pressed.
 bool isRIGHTJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 2) return true;
  else return false;
}
//returns true value if upleft button is pressed on Dpad on joystick 2, returns false value if upleft button on joystick 2 is not pressed.
 bool isUPLEFTJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 1) return true;
  else return false;
}
//returns true value if upright button is pressed on Dpad on joystick 2, returns false value if upright button on joystick 2 is not pressed.
 bool isUPRIGHTJoy1DPadPressed(TJoystick js)
{
  if(joystick.joy1_TopHat == 7) return true;
  else return false;
}
//returns true value if downleft button is pressed on Dpad on joystick 2, returns false value if downleft button on joystick 2 is not pressed.
 bool isDOWNLEFTJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 5) return true;
  else return false;
}
//returns true value if downright button is pressed on Dpad on joystick 2, returns false value if downright button on joystick 2 is not pressed.
 bool isDOWNRIGHTJoy1DPadPressed(TJoystick js)
{
  if(js.joy1_TopHat == 3) return true;
  else return false;
}
void StopDriveMotors()
{
	 	motor[Left] = 0;
		motor[Right] = 0;
}

#define SlideLift_Touch 2
#define ArticArm_Touch 3

task main()
{
	//initializeRobot();
  waitForStart();   // wait for start of tele-op phase

 // StartTask(FrontDetectRing);
//  StartTask(BackDetectRing);

	int MtrPwrLeftFront = 0;
	int MtrPwrLeftBack = 0;
	int MtrPwrRightFront = 0;
	int MtrPwrRightBack = 0;
	int MtrPwrSlideLift = 0;
	int MtrPwrArticArm = 0;

	nMotorEncoder[Right] = 0;
	nMotorEncoder[Left] = 0;
	//nMotorEncoder[SlideLift] = 0; //do not reset slide and arm encoders. Because 0 represents slider or Arm in it's lowest position.
	//nMotorEncoder[ArticArm] = 0;  //They might not be in lowest position. uset test program to manually reset to lowest position if needed.

	while(1)
	{
			alive();
			getJoystickSettings(joystick);

			//Handle Drive Train Power Settings For the Two Joysticks
			float RtPwr = ((joystick.joy1_y1) * 0.78125);
			float LtPwr = ((joystick.joy1_y2) * 0.78125);

			//If the Value Given By the Joysticks is too low to Move the Drive Train, Set the Power to 0
			if(abs(RtPwr) <= 20)
					RtPwr = 0;
			if(abs(LtPwr) <= 20)
					LtPwr = 0;
			if(joy2Btn(4) == 1)
				{
					motor[Collector] = -100;
				}

			else if(joy2Btn(2) == 1)
				{
					motor[Collector] = 100;
				}
			else
					motor[Collector] = 0;

	if(joy2Btn(3) == 1)
				{
					motor[Flag] = -100;
				}

			else if(joy2Btn(1) == 1)
				{
					motor[Flag] = 100;
				}
			else
					motor[Flag] = 0;

		 	motor[Right] = RtPwr;
		 	motor[Left] = LtPwr;

			wait1Msec(10);
	}
}
